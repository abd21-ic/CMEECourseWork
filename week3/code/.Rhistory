MyData <- read.csv("../data/trees.csv", skip = 5) # skip first 5 lines
MyData
write.csv(MyData, "../results/MyData.csv")
dir("../results/") # Check if it worked
write.table(MyData[1,], file = "../results/MyData.csv",append=TRUE) # append
write.csv(MyData, "../results/MyData.csv", row.names=TRUE) # write row names
write.table(MyData, "../results/MyData.csv", col.names=FALSE) # ignore col names
q()
q()
#A simple script to illustrate R input-output.
#Run line by line and check inputs outputs to understand what is happening
MyData <- read.csv("../data/trees.csv", header = TRUE) #import with headers
#A simple script to illustrate R input-output.
#Run line by line and check inputs outputs to understand what is happening
MyData <- read.csv("../data/trees.csv", header = TRUE) #import with headers
write.csv(MyData, "../results/MyData.csv") #write it out as a new file
write.table(MyData[1,], file = "../results/MyData.csv", append=TRUE) #Append to it
write.csv(MyData, "../results/MyData.csv", row.name=TRUE) # write row names
write.table(MyData, "../results/MyData.csv", col.names=FALSE) # ignore column names
source("basic_io.R")
q()
source("control_flow.R")
z <- runif(1) ## Generate a uniformly distributed random number
if (z <= 0.5) {print ("Less than a half")}
if (z <= 0.5) {print ("Less than a half")}
if (z <= 0.5) {print ("Less than a half")}
if (z <= 0.5) {print ("Less than a half")}
z <- runif(1) ## Generate a uniformly distributed random number
if (z <= 0.5) {print ("Less than a half")}
z <- runif(1) ## Generate a uniformly distributed random number
if (z <= 0.5) {print ("Less than a half")}
for (i in 1:10) {
    j <- i * i
    print(paste(i, " squared is", j ))
}
z <- runif(1) ## Generate a uniformly distributed random number
if (z <= 0.5) {print ("Less than a half")}
z <- runif(1) ## Generate a uniformly distributed random number
if (z <= 0.5) {print ("Less than a half")}
z <- runif(1) ## Generate a uniformly distributed random number
if (z <= 0.5) {print ("Less than a half")}
for (i in 1:10) {
    j <- i * i
    print(paste(i, " squared is", j ))
}
for (i in seq(10)) {
    j <- i * i
    print(paste(i, " squared is", j ))
}
for(species in c('Heliodoxa rubinoides', 
                 'Boissonneaua jardini', 
                 'Sula nebouxii')) {
      print(paste('The species is', species))
}
for (i in v1) {
    print(i)
}
v1 <- c("a","bc","def")
for (i in v1) {
    print(i)
}
i <- 0
while (i < 10) {
    i <- i+1
    print(i^2)
}
source("control_flow.R")
source("control_flow.R")
q()
source("break.R")
source("break.R")
q()
source("next.R")
exit
1()
q()
ls(pattern = "MyFun*")
source("boilerplate.R")
ls(pattern = "MyFun*")
source("boilerplate.R")
ls(pattern = "MyFun*")
ls(pattern = "my*")
class(my_function)
is.even <- function(n=2){
if (n%%2 == 0) {
return(paste(n, "is even!"))
} else {
return(paste(n, "is odd!"))
)
}
q()
source("TreeHeight.R")
TreeHeight(3213,2312)
TreeHeight(180,2312)
TreeHeight(1,2312)
TreeHeight(2,2312)
a <- 1.0
class(a)
q()
source("sample.R")
set.seed(12345)
popn <- rnorm(10000) # Generate the population
hist(popn)
source("sample.R")
source("sample.R")
source("sample.R")
x <- 1:20
x
y <- factor(rep(letters[1:5], each = 4)) 
y
tapply(x, y, sum)
attach(iris)
iris
by(iris[,1,2], iris$Species, colMeans)
by(iris[,1,2], iris$Species, colMeans)
by(iris[,1:2], iris$Species, colMeans)
replicate(10, runif(5))
q()
source("browse.R")
n
n
n
n
n
n
n
c
c
c
c
c
q
Q
source("browse.R")
ls()
Q
buggy_function <- function(n) {
result <- n + unknown_variable
return(result)
}
debug(buggy_function)
buggy_function(10)
buggy_function(10)
n
n
Q
doit <- function(x) {
temp_x <- sample(x, replace = TRUE)
if(length(unique(temp_x) > 30) {
doit <- function(x) {
temp_x <- sample(x, replace = TRUE)
if(length(unique(temp_x)) > 30) {
print(paste("Mean of this sample was:", as.character(mean(temp_x))))
}
else {
stop("Couldn't calulate mean: too few unique values!")
}
}
set.ssed(1345)
set.seed(1345)
popn <- rnorm(50)
hist(popn)
lapply(1:15, function(i) doit(popn))
result <- lapply(1:15, function(i) try(doit(popn), FALSE))
result
result <- vector("list", 15)
for(i in 1:15) {
result[[i]] <- try(doit(popn), FALSE)
}
q()
install.packages(c("tidyverse"))
q()
TreeData <- read.csv("../data/trees.csv")
TreeData
TreeHeight(TreeData)
TreeHeights <- TreeHeight(TreeData)
TreeHeights <- TreeHeight(TreeData$Distance.m,TreeData$Angle.degrees)
TreeHeights
TreeHeight <- function(degrees, distance) {
    species <- speices
    radians <- degrees * pi / 180
    height <- distance * tan(radians)
    #print(paste("Tree height is:", height))
    return(height)
}
TreeHeight <- function(degrees, distance) {
    species <- speices
    radians <- degrees * pi / 180
    height <- distance * tan(radians)
    #print(paste("Tree height is:", height))
    return(species, height)
}
TreeHeights <- TreeHeight(TreeData$Species, TreeData$Distance.m,TreeData$Angle.degrees)
TreeHeight <- function(species, degrees, distance) {
    species <- species
    radians <- degrees * pi / 180
    height <- distance * tan(radians)
    #print(paste("Tree height is:", height))
    return(species, height)
}
TreeHeights <- TreeHeight(TreeData$Species, TreeData$Distance.m,TreeData$Angle.degrees)
TreeHeight <- function(species, degrees, distance) {
    species <- species
    radians <- degrees * pi / 180
    height <- distance * tan(radians)
    #print(paste("Tree height is:", height))
    result <- data.frame(Species = species, Height = height)
    return(result)
}
TreeHeights <- TreeHeight(TreeData$Species, TreeData$Distance.m,TreeData$Angle.degrees)
TreeHeights
# This function calculates heights of trees given distance of each tree 
# from its base and angle to its top, using  the trigonometric formula 
#
# height = distance * tan(radians)
#
# ARGUMENTS
# degrees:   The angle of elevation of tree
# distance:  The distance from base of tree (e.g., meters)
#
# OUTPUT
# The heights of the tree, same units as "distance"
TreeData <- read.csv("../data/trees.csv")
TreeHeight <- function(species, degrees, distance) {
    species <- species
    radians <- degrees * pi / 180
    height <- distance * tan(radians)
    #print(paste("Tree height is:", height))
    result <- data.frame(Species = species, Height = height)
    return(result)
}
TreeHts <- TreeHeight(TreeData$Species, TreeData$Distance.m,TreeData$Angle.degrees)
write.csv(TreeHts, "../results/TreeHts.csv")
q()
load("../data/KeyWestAnnualMeanTemperature.RData")
plot(ats)
help.cor
?cor
head(ats)
ats
FloridaTempCorrelation <- cor(ats$years, ats$temperature)
FloridaTempCorrelation <- cor(ats$Year, ats$Temp)
head(ats)
str(ats)
FloridaTempCorrelation <- cor(ats$Year, ats$Temp)
FloridaTempCorrelation
for (i in 1:1000) {
    SampleTemp <- sample(ats$Temp)
    SampleCorrelation[i] <- cor(ats$Year, SampleTemp)
}
SampleCorrelation <- numeric(1000)
for (i in 1:1000) {
    SampleTemp <- sample(ats$Temp)
    SampleCorrelation[i] <- cor(ats$Year, SampleTemp)
}
head(SampleCorrelation)
num <- 1000
SampleCorrelation <- numeric(num)
for (i in 1:num) {
    SampleTemp <- sample(ats$Temp)
    SampleCorrelation[i] <- cor(ats$Year, SampleTemp)
}
Pvalue <- mean(SampleCorrelation > FloridaTempCorrelation)
Pvalue
FloridaTempCorrelation <- cor(ats$Year, ats$Temp)
num <- 1000
SampleCorrelation <- numeric(num)
for (i in 1:num) {
    SampleTemp <- sample(ats$Temp)
    SampleCorrelation[i] <- cor(ats$Year, SampleTemp)
}
Pvalue <- mean(SampleCorrelation > FloridaTempCorrelation)
Pvalue
SampleCorrelation
num <- 1000
SampleCorrelation <- numeric(num)
for (i in 1:num) {
    SampleTemp <- sample(ats$Temp)
    SampleCorrelation[i] <- cor(ats$Year, SampleTemp)
}
SampleCorrelation
SampleCorrelation <- numeric(1000)
for (i in 1:1000) {
    SampleTemp <- sample(ats$Temp)
    SampleCorrelation[i] <- cor(ats$Year, SampleTemp)
}
SampleCorrelation
for (i in 1:1000) {
    SampleTemp <- sample(ats$Temp)
    SampleCorrelation[i] <- cor(ats$Year, SampleTemp)
}
Pvalue <- mean(SampleCorrelation > FloridaTempCorrelation)
Pvalue
SampleCorrelation <- numeric(10000)
for (i in 1:10000) {
    SampleTemp <- sample(ats$Temp)
    SampleCorrelation[i] <- cor(ats$Year, SampleTemp)
}
Pvalue <- mean(SampleCorrelation > FloridaTempCorrelation)
Pvalue
SampleCorrelation <- numeric(10000)
for (i in 1:10000) {
    SampleTemp <- sample(ats$Temp)
    SampleCorrelation[i] <- cor(ats$Year, SampleTemp)
    return (SampleCorrelation)
}
Pvalue <- mean(SampleCorrelation > FloridaTempCorrelation)
Pvalue
FloridaTempCorrelation
SampleCorrelation <- numeric(1000000)
for (i in 1:1000000) {
    SampleTemp <- sample(ats$Temp)
    SampleCorrelation[i] <- cor(ats$Year, SampleTemp)
}
Pvalue <- mean(SampleCorrelation > FloridaTempCorrelation)
Pvalue
Pvalue <- (SampleCorrelation > FloridaTempCorrelation)
Pvalue <- count(SampleCorrelation > FloridaTempCorrelation)
sum(SampleCorrelation > FloridaTempCorrelation)
FloridaTempCorrelation
head(SampleCorrelation)
abs(SampleCorrelation)
sum(SampleCorrelation > FloridaTempCorrelation)
abs(SampleCorrelation)
head(SampleCorrelation)
SampleCorrelation
PValue
Pvalue <- sum(SampleCorrelation > FloridaTempCorrelation) #Tests for any sample with greater correlation than data observed.
PValue
Pvalue <- sum(SampleCorrelation > FloridaTempCorrelation) #Tests for any sample with greater correlation than data observed.
Pvalue
FloridaTempCorrelation
mean(SampleCorrelation)
abs(SampleCorrelation) #Absolute Value of the sample correlation
mean(SampleCorrelation)
mean(abs(SampleCorrelation))
for (i in 1:1000000) {
    SampleTemp <- sample(ats$Temp) #Takes a sample of the data temperatures
    SampleYear <- sample(ats$Year)
    SampleCorrelation[i] <- cor(SampleYear, SampleTemp) #correlates sample tempetature with random year and calulates correlation
}
Pvalue <- sum(abs(SampleCorrelation > FloridaTempCorrelation)) #Tests for any sample with greater correlation than data observed.
Pvalue
FloridaTempCorrelation <- cor(ats$Year, ats$Temp) #Calulates correlation of our data
FloridaTempCorrelation
###### Rudimentary P-Value Test ######
SampleCorrelation <- numeric(1000000) #Sample Vector of 1000000
for (i in 1:1000000) {
    SampleTemp <- sample(ats$Temp) #Takes a sample of the data temperatures
    SampleYear <- sample(ats$Year)
    SampleCorrelation[i] <- cor(SampleYear, SampleTemp) #correlates sample tempetature with random year and calulates correlation
}
Pvalue <- sum(abs(SampleCorrelation) > FloridaTempCorrelation) #Tests for any sample with greater correlation than data observed.
Pvalue
SampleCorrelation
head(SampleCorrelation)
tail(SampleCorrelation)
Pvalue <- sum(abs(SampleCorrelation) > 0.01) #Tests for any sample with greater correlation than data observed.
Pvalue
Pvalue <- sum(abs(SampleCorrelation) > 0.1) #Tests for any sample with greater correlation than data observed.
Pvalue
Pvalue <- sum(abs(SampleCorrelation) > 0.4) #Tests for any sample with greater correlation than data observed.
Pvalue
Pvalue <- sum(abs(SampleCorrelation) > 0.5) #Tests for any sample with greater correlation than data observed.
Pvalue
Pvalue <- sum(abs(SampleCorrelation) > 0.45) #Tests for any sample with greater correlation than data observed.
Pvalue
MyData <- as.matrix(read.csv("../data/PoundHillData.csv", header = FALSE))
MyData <- as.matrix(read.csv("../data/PoundHillData.csv", header = FALSE))
build_ellipse <- function(hradius, vradius){ # function that returns an ellipse
  npoints = 250
  a <- seq(0, 2 * pi, length = npoints + 1)
  x <- hradius * cos(a)
  y <- vradius * sin(a)  
  return(data.frame(x = x, y = y))
}
N <- 250 # Assign size of the matrix
M <- matrix(rnorm(N * N), N, N) # Build the matrix
eigvals <- eigen(M)$values # Find the eigenvalues
eigDF <- data.frame("Real" = Re(eigvals), "Imaginary" = Im(eigvals)) # Build a dataframe
my_radius <- sqrt(N) # The radius of the circle is sqrt(N)
ellDF <- build_ellipse(my_radius, my_radius) # Dataframe to plot the ellipse
names(ellDF) <- c("Real", "Imaginary") # rename the columns
# plot the eigenvalues
p <- ggplot(eigDF, aes(x = Real, y = Imaginary))
library(ggplot)
build_ellipse <- function(hradius, vradius){ # function that returns an ellipse
  npoints = 250
  a <- seq(0, 2 * pi, length = npoints + 1)
  x <- hradius * cos(a)
  y <- vradius * sin(a)  
  return(data.frame(x = x, y = y))
}
N <- 250 # Assign size of the matrix
M <- matrix(rnorm(N * N), N, N) # Build the matrix
eigvals <- eigen(M)$values # Find the eigenvalues
eigDF <- data.frame("Real" = Re(eigvals), "Imaginary" = Im(eigvals)) # Build a dataframe
my_radius <- sqrt(N) # The radius of the circle is sqrt(N)
ellDF <- build_ellipse(my_radius, my_radius) # Dataframe to plot the ellipse
names(ellDF) <- c("Real", "Imaginary") # rename the columns
# plot the eigenvalues
p <- ggplot(eigDF, aes(x = Real, y = Imaginary))
require(ggplot)
ggplot
install.packages("ggplot2")
library(ggplot2)
build_ellipse <- function(hradius, vradius){ # function that returns an ellipse
  npoints = 250
  a <- seq(0, 2 * pi, length = npoints + 1)
  x <- hradius * cos(a)
  y <- vradius * sin(a)  
  return(data.frame(x = x, y = y))
}
N <- 250 # Assign size of the matrix
M <- matrix(rnorm(N * N), N, N) # Build the matrix
eigvals <- eigen(M)$values # Find the eigenvalues
eigDF <- data.frame("Real" = Re(eigvals), "Imaginary" = Im(eigvals)) # Build a dataframe
my_radius <- sqrt(N) # The radius of the circle is sqrt(N)
ellDF <- build_ellipse(my_radius, my_radius) # Dataframe to plot the ellipse
names(ellDF) <- c("Real", "Imaginary") # rename the columns
# plot the eigenvalues
p <- ggplot(eigDF, aes(x = Real, y = Imaginary))
p <- p +
  geom_point(shape = I(3)) +
  theme(legend.position = "none")
# now add the vertical and horizontal line
p <- p + geom_hline(aes(yintercept = 0))
p <- p + geom_vline(aes(xintercept = 0))
# finally, add the ellipse
p <- p + geom_polygon(data = ellDF, aes(x = Real, y = Imaginary, alpha = 1/20, fill = "red"))
p
build_ellipse <- function(hradius, vradius){ # function that returns an ellipse
  npoints = 250
  a <- seq(0, 2 * pi, length = npoints + 1)
  x <- hradius * cos(a)
  y <- vradius * sin(a)  
  return(data.frame(x = x, y = y))
}
N <- 250 # Assign size of the matrix
M <- matrix(rnorm(N * N), N, N) # Build the matrix
eigvals <- eigen(M)$values # Find the eigenvalues
eigDF <- data.frame("Real" = Re(eigvals), "Imaginary" = Im(eigvals)) # Build a dataframe
my_radius <- sqrt(N) # The radius of the circle is sqrt(N)
ellDF <- build_ellipse(my_radius, my_radius) # Dataframe to plot the ellipse
names(ellDF) <- c("Real", "Imaginary") # rename the columns
# plot the eigenvalues
p <- ggplot(eigDF, aes(x = Real, y = Imaginary))
p <- p +
  geom_point(shape = I(3)) +
  theme(legend.position = "none")
# now add the vertical and horizontal line
p <- p + geom_hline(aes(yintercept = 0))
p <- p + geom_vline(aes(xintercept = 0))
# finally, add the ellipse
p <- p + geom_polygon(data = ellDF, aes(x = Real, y = Imaginary, alpha = 1/20, fill = "red"))
p
# creating pdf file
pdf("../results/Girko.pdf")
print(p)
dev.off()
a$ymin <- rep(0, dim(a)[1]) # append a column of zeros
# Print the first linerange
p <- ggplot(a)
p <- p + geom_linerange(data = a, aes(
                          x = x,
                          ymin = ymin,
                          ymax = y1,
                          size = (0.5)
                          ),
                        colour = "#E69F00",
                        alpha = 1/2, show.legend = FALSE)
a <- read.table("../data/Results.txt", header = TRUE)
a$ymin <- rep(0, dim(a)[1]) # append a column of zeros
# Print the first linerange
p <- ggplot(a)
p <- p + geom_linerange(data = a, aes(
                          x = x,
                          ymin = ymin,
                          ymax = y1,
                          size = (0.5)
                          ),
                        colour = "#E69F00",
                        alpha = 1/2, show.legend = FALSE)
# Print the second linerange
p <- p + geom_linerange(data = a, aes(
                          x = x,
                          ymin = ymin,
                          ymax = y2,
                          size = (0.5)
                          ),
                        colour = "#56B4E9",
                        alpha = 1/2, show.legend = FALSE)
# Print the third linerange:
p <- p + geom_linerange(data = a, aes(
                          x = x,
                          ymin = ymin,
                          ymax = y3,
                          size = (0.5)
                          ),
                        colour = "#D55E00",
                        alpha = 1/2, show.legend = FALSE)
# Annotate the plot with labels:
p <- p + geom_text(data = a, aes(x = x, y = -500, label = Label))
# now set the axis labels, remove the legend, and prepare for bw printing
p <- p + scale_x_continuous("My x axis",
                            breaks = seq(3, 5, by = 0.05)) + 
                            scale_y_continuous("My y axis") + 
                            theme_bw() + 
                            theme(legend.position = "none")
p
p
q()
